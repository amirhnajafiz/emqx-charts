---
serviceMonitor: {}
emqx:
  ## Default values for emqx.
  ## This is a YAML-formatted file.
  ## Declare variables to be passed into your templates.

  image:
    # repository: emqx/emqx
    # pullPolicy: IfNotPresent
    pullPolicy: Always
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ##
    # pullSecrets:
    # - myRegistryKeySecretName

  ## Forces the recreation of pods during helm upgrades.
  ## This can be useful to update configuration values even if the container image did not change.
  recreatePods: true

  persistence:
    enabled: false
    size: 300Mi
    ## If defined, volume.beta.kubernetes.io/storage-class: <storageClass>
    ## Default: volume.alpha.kubernetes.io/storage-class: default
    # storageClass: "-"
    accessMode: ReadWriteOnce
    ## Existing PersistentVolumeClaims
    ## The value is evaluated as a template
    ## So, for example, the name can depend on .Release or .Chart
    # existingClaim: ""

  # Containers that run before the creation of EMQX containers. They can contain utilities or setup scripts.
  initContainers: {}
    # - name: mysql-probe
    #   image: alpine
    #   command: ["sh", "-c", "for i in $(seq 1 300); do nc -zvw1 mysql 3306 && exit 0 || sleep 3; done; exit 1"]
  
  # replicas is used for the number of core nodes
  replicas: 3
  # replicantsCount is used for the number of replicant nodes
  replicantsCount: 3

  extraEnv:
    - name: HOME
      value: /opt/emqx/data

  ## EMQX configuration item, see the documentation (https://hub.docker.com/r/emqx/emqx)
  emqxConfig:
    EMQX_CLUSTER__DISCOVERY_STRATEGY: k8s
    EMQX_CLUSTER__DNS__NAME:  emqx-staging.svc.cluster.local
    EMQX_CLUSTER__K8S__ADDRESS_TYPE: hostname
    EMQX_CLUSTER__K8S__APISERVER: https://kubernetes.default.svc:443
    EMQX_CLUSTER__K8S__NAMESPACE: '{{ .Release.Namespace }}'
    EMQX_CLUSTER__K8S__SERVICE_NAME: '{{ .Release.Name }}-headless'
    EMQX_CLUSTER__K8S__SUFFIX: svc.cluster.local

  ## EMQX Enterprise Edition requires manual creation of a Secret containing the licensed content. Write the name of Secret to the value of "emqxLicneseSecretName"
  ## Example:
  ##   kubectl create secret generic emqx-license-secret-name --from-file=/path/to/emqx.lic
  emqxLicneseSecretName:

  service:
    ## Service type
    ##
    type: ClusterIP
    ## Port for MQTT
    ##
    mqtt: 1883
    ## Port for MQTT(SSL)
    ##
    mqttssl: 8883
    ## Port for mgmt API
    ##
    mgmt: 8081
    ## Port for WebSocket/HTTP
    ##
    ws: 8083
    ## Port for WSS/HTTPS
    ##
    wss: 8084
    ## Port for dashboard
    ##
    dashboard: 18083
    ## Port for dashboard HTTPS
    ##
    # dashboardtls: 18084
    ## Specify the nodePort(s) value for the LoadBalancer and NodePort service types.
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
    ##
    nodePorts:
      mqtt:
      mqttssl:
      mgmt:
      ws:
      wss:
      dashboard:
      dashboardtls:
    ## Set the LoadBalancer service type to internal only.
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#internal-load-balancer
    ##
    # loadBalancerIP:
    ## Load Balancer sources
    ## ref: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/#restrict-access-for-loadbalancer-service
    ## Example:
    ## loadBalancerSourceRanges:
    ## - 10.10.10.0/24
    ##
    loadBalancerSourceRanges: []
    ## Provide any additional annotations which may be required. Evaluated as a template
    ##
    annotations: {}

  nodeSelector: {}

  tolerations: []

  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchExpressions:
                - key: app
                  operator: In
                  values:
                    - emqx
            topologyKey: kubernetes.io/hostname

  podSecurityContext:
    enabled: true
    fsGroup: null
    fsGroupChangePolicy: null
    runAsUser: null
    supplementalGroups: null
    sysctls:
      - name: net.core.somaxconn
        value: "32768"

  containerSecurityContext:
    enabled: false
    runAsNonRoot: true
    runAsUser: 1000
